<p># Literate Parsing in Markdown</p>
<p>This file is a literate haskell-Markdown file, explaining and implementing a trivial parser combinator in Haskell</p>
<p>First we declare a module:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">module</span> <span class="dt">Parse</span> <span class="kw">where</span></a></code></pre></div>
<p>Then we define our parser type. A parser must read some input - in this case a string - and attempt to match it. The simplest idea might be a predicate:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">type</span> naiveParser <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
<p>Unfortunately this is not very useful - if we want parsers that can match anything beyond a constant string, then we’re going to want to know <em>what</em> was matched. So lets return that (if successful):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">type</span> naiveParser&#39; a <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a></code></pre></div>
<p>Now we can at least extract some data out of the parser. However, although we can get a result out, we don’t know what was done with the input. We’d like the ability to combine parsers in sequence, which means knowing where to start the next parser at. So at the very least, we’d need to output the remaining input:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">type</span> naiveParser&#39;&#39; a <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">String</span>, a)</a></code></pre></div>
<p>Now our parser (if successful) can return where to begin the next parser, and also the parsed value. If it fails, we get Nothing. This is great in a successful case, but on failure, it would be useful to be able to indicate more clearly where errors happened - otherwise we get no information on how to fix our invalid input!</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">data</span> <span class="dt">SimpleParseError</span> <span class="fu">=</span> <span class="dt">SimpleParseError</span> {<span class="ot"> reason ::</span> <span class="dt">String</span> }</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">type</span> parserWithErrors a <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">SimpleParseError</span> (<span class="dt">String</span>, a)</a></code></pre></div>
<p>Now every time we run a parser, we either fail - with a good reason - or we advance, producing a value and the remaining input to be parsed.</p>
<p>Let’s try this and actually write some parsers and combinators. The most trivial parser (that still does useful work) just parses a single expected char:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">charP ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> parserWithErrors <span class="dt">Char</span></a>
<a class="sourceLine" id="cb6-2" title="2">charP expected <span class="fu">=</span> \str <span class="ot">-&gt;</span> <span class="kw">case</span> str <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-3" title="3">                     (c<span class="fu">:</span>cs) <span class="kw">if</span> c <span class="fu">==</span> expected <span class="ot">-&gt;</span> <span class="dt">Right</span> (cs, c)</a>
<a class="sourceLine" id="cb6-4" title="4">                     [] <span class="ot">-&gt;</span> <span class="dt">Left</span> endOfInput</a>
<a class="sourceLine" id="cb6-5" title="5">                     (x<span class="fu">:</span>_) <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="fu">$</span> wrongChar x</a>
<a class="sourceLine" id="cb6-6" title="6">                     <span class="kw">where</span> endOfInput <span class="fu">=</span> <span class="dt">SimpleParseError</span> <span class="st">&quot;Expected &quot;</span> <span class="fu">&lt;&gt;</span> expected <span class="fu">&lt;&gt;&lt;</span> <span class="st">&quot;, found end of input&quot;</span></a>
<a class="sourceLine" id="cb6-7" title="7">                     wrongChar w <span class="fu">=</span> <span class="dt">SimpleParseError</span> <span class="st">&quot;Expected &quot;</span> <span class="fu">&lt;&gt;</span> expected <span class="fu">&lt;&gt;&lt;</span> <span class="st">&quot;, found &quot;</span> <span class="fu">&lt;&gt;</span> w</a></code></pre></div>
